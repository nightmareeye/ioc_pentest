import re
from pymisp import PyMISP
from datetime import datetime
from fastapi import Depends
from models import Vulnerability_table
from database import get_db, Session
from loguru import logger
from sqlalchemy.exc import IntegrityError
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Pattern definitions for identifying vulnerability types.
patterns = {
    "Broken Access Control": [r"xls", r"permissions", r"unauthorized"],
    "Cryptographic Failures": [r"crypto", r"encryption", r"ssl", r"tls"],
    "Injection": [r"injection", r"sql", r"xss", r"cross-site"],
    "Insecure Design": [r"design flaw", r"misconfiguration"],
    "Vulnerable and Outdated Components": [r"vulnerable version", r"outdated", r"obsolete"],
    "Identification and Authentication Failures": [r"password", r"authentication", r"credential"],
    "Software and Data Integrity Failures": [r"tampering", r"integrity", r"corruption"],
    "Security Logging and Monitoring Failures": [r"logging", r"monitoring", r"audit"],
    "Server-Side Request Forgery": [r"ssrf", r"server-side request forgery"]
}


class Vulnerability:
    """
    Represents a security vulnerability with a specific type identified in an event.

    Attributes:
        event_id (int): The unique identifier of the event.
        type (str): The type of vulnerability, which corresponds to a defined pattern.
    """

    def __init__(self, event_id, type):
        self.event_id = event_id
        self.type = type

    def __str__(self):
        return f"Event ID: {self.event_id}, Type: {self.type}"


class MispConnector:
    """
    Connects to a MISP instance and a PostgreSQL database to manage vulnerabilities.

    Attributes:
        url (str): The URL of the MISP instance.
        key (str): The API key for accessing the MISP instance.
        dbname (str): The name of the PostgreSQL database.
        dbuser (str): The username for the PostgreSQL database.
        dbpassword (str): The password for the PostgreSQL database.
        dbhost (str): The host of the PostgreSQL database.
    """

    def __init__(self, misp_url, misp_key, database: Session = Depends(get_db)):
        self.misp = PyMISP(misp_url, misp_key, ssl=False, debug=True)
        self.database = database

    def save_vulnerability(self, vulnerability):
        """
        Saves a vulnerability to the database.

        Args:
            vulnerability (Vulnerability): The vulnerability to be saved.
        """
        vuln = Vulnerability_table(
            event_id=vulnerability.event_id, type=vulnerability.type, scan_time=datetime.now())
        try:
            self.database.add(vuln)
            self.database.commit()
        except IntegrityError:
            self.database.rollback()
            logger.info(f"Vulnerability {vulnerability.event_id} of type {vulnerability.type} already exists in the database.")

    def determine_vulnerability_type(self, attribute_value):
        """
        Determines the type of a vulnerability based on its attribute value and predefined patterns.

        Args:
            attribute_value (str): The value of the attribute to be checked.

        Returns:
            str: The determined type of the vulnerability, or 'Unknown' if not matched.
        """
        for vuln_type, regex_patterns in patterns.items():
            for pattern in regex_patterns:
                if re.search(pattern, attribute_value, re.IGNORECASE):
                    return vuln_type
        return "Unknown"

    def search_and_save_vulnerabilities(self):
        """
        Searches for vulnerabilities in the MISP events and attributes, and saves them in the database.
        """
        search_keywords = ["xls", "permissions", "unauthorized", "crypto", "encryption", "ssl", "tls", 
                           "injection", "sql", "xss", "cross-site", "design flaw", "misconfiguration",
                           "vulnerable version", "outdated", "obsolete", "password", "authentication",
                           "credential", "tampering", "integrity", "corruption", "logging", "monitoring",
                           "audit", "ssrf", "server-side request forgery"]
        
        # Fetch recent events
        events = self.misp.events()
        logger.info(f"Fetched {len(events)} events from MISP")
        logger.info(self.misp.get_event(44))
        for event in events:
            event_id = event['id']
            event_info = event['info']
            if any(keyword in event_info for keyword in search_keywords):
                attributes = self.misp.get_event(event_id)['Event']['Attribute']
                for attribute in attributes:
                    vuln_type = self.determine_vulnerability_type(attribute['value'])
                    if vuln_type != "Unknown":
                        vulnerability = Vulnerability(event_id, vuln_type)
                        self.save_vulnerability(vulnerability)
        logger.info(f"Successfuly fetched all")

    def display_vulnerabilities(self):
        """Displays all vulnerabilities stored in the database."""
        records = self.database.query(Vulnerability_table).all()
        print("Vulnerabilities found:")
        for record in records:
            print(", ".join(map(str, record)))

    def delete_vulnerabilities_by_id_and_type(self, event_id, vuln_type):
        """
        Deletes vulnerabilities from the table based on event_id and vulnerability type.

        Args:
            event_id (int): The event identifier.
            vuln_type (str): The type of vulnerability to delete.
        """
        try:
            vuln = self.database.query(Vulnerability_table).filter(
                Vulnerability_table.event_id == event_id and Vulnerability_table.type == vuln_type).first()
            self.database.delete(vuln)
            self.database.commit()
            print(f"Deleted vulnerabilities with Event ID: {event_id} and Type: {vuln_type}")
        except Exception as e:
            print(f"Error deleting vulnerabilities: {e}")


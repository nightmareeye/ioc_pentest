import os
import pika
import json
from zapv2 import ZAPv2
from loguru import logger


RABBITMQ_HOST = 'localhost'
RABBITMQ_QUEUE = 'vulnerabilities_queue'

ZAP_API_URL = 'http://localhost:8080'
ZAP_API_KEY = 'changeme'  

zap = ZAPv2(apikey=ZAP_API_KEY, proxies={
            'http': ZAP_API_URL, 'https': ZAP_API_URL})


def load_groovy_script(script_name, script_path):
    """Загружает и включает скрипт Groovy в ZAP."""
    zap.script.load(scriptname=script_name, scripttype='active',
                    scriptengine='Oracle Nashorn', filename=script_path, scriptdescription='')
    zap.script.enable(scriptname=script_name)


def zap_scan(ip_address, port, script_path, subcategory):
    """Запускает сканирование ZAP с использованием предоставленного скрипта."""
    target_url = f"http://{ip_address}:{port}"

    script_name = f"{subcategory}"
    load_groovy_script(script_name, script_path)

    logger.info(f"Accessing target URL: {target_url}")
    zap.urlopen(target_url)

    logger.info(f"Starting active scan on: {target_url}")
    scan_id = zap.ascan.scan(
        target=target_url, recurse=True, contextid=None, scanpolicyname=None)

    while int(zap.ascan.status(scan_id)) < 100:
        logger.info(f"Scan progress: {zap.ascan.status(scan_id)}%")

    zap.script.disable(scriptname=script_name)
    logger.info("Scan completed")

    scan_results = zap.core.alerts(baseurl=target_url)
    logger.info(f"Scan results for {target_url}:")
    for alert in scan_results:
        logger.info(f"Alert: {alert}")


def callback(ch, method, properties, body):
    """Обработчик сообщений из очереди RabbitMQ."""
    message = json.loads(body)
    ip_address = message.get('ip_address')
    port = message.get('port')
    script_path = message.get('script_path')
    subcategory = message.get('subcategory')

    if ip_address and port and script_path and subcategory and os.path.exists(script_path):
        zap_scan(ip_address, port, script_path, subcategory)
    else:
        logger.info(f"Invalid message or script path not found: {message}")

    ch.basic_ack(delivery_tag=method.delivery_tag)


def consume_messages():
    """Настраивает потребление сообщений из очереди RabbitMQ."""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters(host=RABBITMQ_HOST))
    channel = connection.channel()
    channel.queue_declare(queue=RABBITMQ_QUEUE)
    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(queue=RABBITMQ_QUEUE, on_message_callback=callback)
    logger.info("Waiting for messages. To exit press CTRL+C")
    channel.start_consuming()


if __name__ == "__main__":
    consume_messages()

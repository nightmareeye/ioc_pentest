"""Main of IOC Pentest app
"""
from loguru import logger
from fastapi import FastAPI, Request, Depends, Form, status, HTTPException, Response
from fastapi.templating import Jinja2Templates
from fastapi.responses import RedirectResponse
from sqlalchemy import desc
from fastapi.staticfiles import StaticFiles
from database import init_db, get_db, Session
from network_scanner import NetworkScanner
from models import Network, Port_services, Vulnerability_table

# pylint: disable=invalid-name
templates = Jinja2Templates(directory="templates")

init_db()

app = FastAPI()
logger = logger.opt(colors=True)
# pylint: enable=invalid-name
app.mount("/static", StaticFiles(directory="static"), name="static")


def get_latest_notifications(database: Session):
    """Возвращает последние 5 уведомлений с viewed=False."""
    logger.info("Fetching latest notifications")
    latest_vulnerabilities = database.query(Vulnerability_table).filter(Vulnerability_table.viewed == False).order_by(desc(Vulnerability_table.scan_time)).limit(5).all()
    return [{
        "event_id": vulnerability.id,
        "type": vulnerability.type,
    } for vulnerability in latest_vulnerabilities]



@app.get("/connect")
async def connect(request: Request):
    pass



@app.get("/")
async def home(request: Request, database: Session = Depends(get_db)):
    """Main page with todo list
    """
    logger.info("Main page")
    notifs = get_latest_notifications(database)
    return templates.TemplateResponse("index.html", {"request": request, "notifications": notifs})

@app.get("/servers")
async def servers_get(request: Request, database: Session = Depends(get_db)):
    logger.info("Servers page")
    systems = database.query(Network).all()
    notifs = get_latest_notifications(database)
    return templates.TemplateResponse("servers.html", {"request": request, "systems": systems, "notifications": notifs})

@app.get("/scan")
async def servers_scan(request: Request, database: Session = Depends(get_db)):
    scanner = NetworkScanner(database)
    subnets = scanner.get_local_subnets()
    for subnet in subnets:
        logger.info(f"Scanning subnet: {subnet}")
        scan_results = scanner.scan_subnet(subnet)
        print(scan_results.all_hosts())
        data = scanner.parse_scan_results(scan_results)
        scanner.upsert_data(data)

    response = RedirectResponse(url=app.url_path_for("servers_get"), status_code=status.HTTP_303_SEE_OTHER)
    return response

@app.post("/scan_delete_all")
async def servers_delete_all(request: Request, database: Session = Depends(get_db)):
    scanner = NetworkScanner(database)
    scanner.delete_all_network_scan_records()
    response = RedirectResponse(url=app.url_path_for("servers_get"), status_code=status.HTTP_303_SEE_OTHER)
    return response

@app.post("/scan_delete/{server_id}")
async def servers_delete(request: Request, server_id: int, database: Session = Depends(get_db)):
    scanner = NetworkScanner(database)
    scanner.delete_network_scan_record(server_id)
    response = RedirectResponse(url=app.url_path_for("servers_get"), status_code=status.HTTP_303_SEE_OTHER)
    systems = database.query(Network).all()
    response.body(systems)
    return response

@app.post("/servers/{server_id}")
async def servers_post(request: Request, server_id: int):
    logger.info("Servers page")
    return templates.TemplateResponse("servers.html", {"request": request})


@app.get("/stats")
async def stats(request: Request):
    logger.info("Stats page")
    return templates.TemplateResponse("stats.html", {"request": request})


@app.get("/pentest")
async def pentest_get(request: Request):
    logger.info("Pentest page")
    return templates.TemplateResponse("pentest.html", {"request": request})

@app.post("/pentest/{server_id}")
async def pentest_post(request: Request):
    logger.info("Pentest page")
    return templates.TemplateResponse("pentest.html", {"request": request})

@app.get("/notifications")
async def notifications(request: Request, database: Session = Depends(get_db)):
    logger.info("Notifications page")
    vulnerabilities = database.query(Vulnerability_table).all()
    notifs = get_latest_notifications(database)
    return templates.TemplateResponse("notifications.html", {"request": request, "vulnerabilities": vulnerabilities, "notifications": notifs})

@app.get("/notifications/{event_id}")
async def notifications_detail(request: Request, event_id: int, database: Session = Depends(get_db)):
    logger.info(f"Notification detail page for event_id: {event_id}")
    vulnerability = database.query(Vulnerability_table).filter(Vulnerability_table.id == event_id).first()
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Notification not found")
    notifs = get_latest_notifications(database)
    return templates.TemplateResponse("notification_detail.html", {"request": request, "vulnerability": vulnerability, "notifications": notifs})
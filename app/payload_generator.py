"""Generates payloads
"""
import os
import json
import pika
from fastapi import Depends
from database import get_db, Session
from models import Vulnerability_table
from apscheduler.schedulers.blocking import BlockingScheduler
from loguru import logger


RABBITMQ_HOST = 'localhost'
RABBITMQ_QUEUE = 'vulnerabilities_queue'


PAYLOADS_DIR = "/PayloadAllTheThings"  

VULNERABILITY_MAPPING = {
    "Broken Access Control": [
        "IDOR",
        "Privilege Escalation",
        "Bypassing File Upload Restrictions",
        "CORS Misconfiguration"
    ],
    "Cryptographic Failures": [
        "XXE"
    ],
    "Injection": [
        "SQL Injection",
        "Command Injection",
        "ORM Injection",
        "XML Injection",
        "SSI Injection",
        "XPath Injection",
        "LDAP Injection",
        "Hibernate Injection",
        "Template Injection"
    ],
    "Insecure Design": [
        "Deserialization",
        "Subdomain Takeover"
    ],
    "Security Misconfiguration": [
        "CORS Misconfiguration",
        "HTTP Headers Misconfiguration",
        "Security Headers Server Configuration"
    ],
    "Vulnerable and Outdated Components": [
        "Dependencies",
        "CMS vulnerabilities"
    ],
    "Identification and Authentication Failures": [
        "JWT attacks",
        "OAuth attacks",
        "Bypassing Authentication"
    ],
    "Software and Data Integrity Failures": [
        "Insecure Deserialization",
        "Race Condition"
    ],
    "Security Logging and Monitoring Failures": [
        "Logging Payloads"
    ],
    "Server-Side Request Forgery": [
        "SSRF"
    ]
}

def get_payload_content(category: str) -> dict:
    """Возвращает содержимое всех файлов payload.groovy для указанной категории уязвимостей.
    """
    payloads = {}
    subcategories = VULNERABILITY_MAPPING.get(category, [])
    if not subcategories:
        return payloads
    
    payloads[category] = {}
    for subcategory in subcategories:
        folder_path = os.path.join(PAYLOADS_DIR, category, subcategory)
        file_path = os.path.join(folder_path, "payload.groovy")
        if os.path.exists(file_path):
            payloads[category][subcategory] = file_path
    return payloads

def send_to_rabbitmq(message: str):
    """Отправляет сообщение в RabbitMQ.
    """
    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_HOST))
    channel = connection.channel()
    channel.queue_declare(queue=RABBITMQ_QUEUE)
    channel.basic_publish(exchange='', routing_key=RABBITMQ_QUEUE, body=message)
    connection.close()

def process_vulnerability(category: str, database: Session = Depends(get_db)):
    """Обрабатывает уязвимости из базы данных и отправляет полезные нагрузки в RabbitMQ.
    """
    payloads =  get_payload_content(category)
    vulnerabilities = database.query(Vulnerability_table).all()
    for vulnerability in vulnerabilities:
        category = vulnerability.type
        if category in payloads:
            for subcategory, payload_content in payloads[category].items():
                message = {
                    "ip_address": vulnerability.ip_address,
                    "port": vulnerability.port,  
                    "script_path": payload_content,
                    "subcategory": subcategory
                }
                send_to_rabbitmq(json.dumps(message))
                logger.info(f"Sent message: {message}")

def process_vulnerabilities(database: Session = Depends(get_db)):
    """Обрабатывает уязвимости из базы данных и отправляет полезные нагрузки в RabbitMQ."""
    vulnerabilities = database.query(Vulnerability_table).filter(Vulnerability_table.viewed == False).all()
    for vulnerability in vulnerabilities:
        category = vulnerability.type
        payloads = get_payload_content(category)
        if category in payloads:
            for subcategory, payload_content in payloads[category].items():
                message = {
                    "ip_address": vulnerability.ip_address,
                    "port": vulnerability.port,  
                    "script_path": payload_content,
                    "subcategory": subcategory
                }
                send_to_rabbitmq(json.dumps(message))
                logger.info(f"Sent message: {message}")
                
                vulnerability.viewed = True
                database.commit()

def scheduled_job():
    """Задача, которая будет запускаться по расписанию."""
    process_vulnerabilities(Depends(get_db))

def start_auto_pentesting():
    scheduler = BlockingScheduler()
    scheduler.add_job(scheduled_job, 'interval', minutes=1)  # Проверка каждые 1 минуту
    logger.info("Starting scheduler...")
    scheduler.start()

def stop_auto_pentesting():
    sheduler = BlockingScheduler()
    sheduler.shutdown(wait=True)
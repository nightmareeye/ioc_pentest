import re
import psycopg2
import os
from pymisp import PyMISP
from datetime import datetime
import time

# Pattern definitions for identifying vulnerability types.
patterns = {
    "Broken Access Control": [r"access", r"permissions", r"unauthorized"],
    "Cryptographic Failures": [r"crypto", r"encryption", r"ssl", r"tls"],
    "Injection": [r"injection", r"sql", r"xss", r"cross-site"],
    "Insecure Design": [r"design flaw", r"misconfiguration"],
    "Vulnerable and Outdated Components": [r"vulnerable version", r"outdated", r"obsolete"],
    "Identification and Authentication Failures": [r"password", r"authentication", r"credential"],
    "Software and Data Integrity Failures": [r"tampering", r"integrity", r"corruption"],
    "Security Logging and Monitoring Failures": [r"logging", r"monitoring", r"audit"],
    "Server-Side Request Forgery (SSRF)": [r"ssrf", r"server-side request forgery"]
}


class Vulnerability:
    """
    Represents a security vulnerability with a specific type identified in an event.

    Attributes:
        event_id (int): The unique identifier of the event.
        type (str): The type of vulnerability, which corresponds to a defined pattern.
    """

    def __init__(self, event_id, type):
        self.event_id = event_id
        self.type = type

    def __str__(self):
        return f"Event ID: {self.event_id}, Type: {self.type}"


class MispConnector:
    """
    Connects to a MISP instance and a PostgreSQL database to manage vulnerabilities.

    Attributes:
        url (str): The URL of the MISP instance.
        key (str): The API key for accessing the MISP instance.
        dbname (str): The name of the PostgreSQL database.
        dbuser (str): The username for the PostgreSQL database.
        dbpassword (str): The password for the PostgreSQL database.
        dbhost (str): The host of the PostgreSQL database.
    """

    def __init__(self, url, key, dbname, dbuser, dbpassword, dbhost):
        self.misp = PyMISP(url, key, ssl=False)
        self.conn = psycopg2.connect(
            dbname=dbname,
            user=dbuser,
            password=dbpassword,
            host=dbhost
        )
        self.cursor = self.conn.cursor()
        self.create_vulnerabilities_table()

    def create_vulnerabilities_table(self):
        """Creates a table for vulnerabilities in the database if it does not exist."""
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                event_id INT,
                type TEXT,
                scan_time TIMESTAMP
            )
        ''')
        self.conn.commit()

    def save_vulnerability(self, vulnerability):
        """
        Saves a vulnerability to the database.

        Args:
            vulnerability (Vulnerability): The vulnerability to be saved.
        """
        self.cursor.execute('''
            INSERT INTO vulnerabilities (event_id, type, scan_time)
            VALUES (%s, %s, %s)
        ''', (vulnerability.event_id, vulnerability.type, datetime.now()))
        self.conn.commit()

    def determine_vulnerability_type(self, attribute_value, patterns):
        """
        Determines the type of a vulnerability based on its attribute value and predefined patterns.

        Args:
            attribute_value (str): The value of the attribute to be checked.
            patterns (dict): The dictionary containing vulnerability types and their associated regex patterns.

        Returns:
            str: The determined type of the vulnerability, or 'Unknown' if not matched.
        """
        for vuln_type, regex_patterns in patterns.items():
            for pattern in regex_patterns:
                if re.search(pattern, attribute_value, re.IGNORECASE):
                    return vuln_type
        return "Unknown"

    def search_and_save_vulnerabilities(self, patterns):
        """
        Searches for vulnerabilities in the MISP attributes and saves them in the database.

        Args:
            patterns (dict): The dictionary containing vulnerability types and their associated regex patterns.
        """
        attributes = self.misp.search(controller='attributes', pythonify=True)
        for attribute in attributes:
            vuln_type = self.determine_vulnerability_type(attribute.value, patterns)
            if vuln_type != "Unknown":
                vulnerability = Vulnerability(attribute.event_id, vuln_type)
                self.save_vulnerability(vulnerability)

    def close(self):
        """Closes the database connection."""
        self.cursor.close()
        self.conn.close()

    def display_vulnerabilities(self):
        """Displays all vulnerabilities stored in the database."""
        self.cursor.execute('SELECT * FROM vulnerabilities')
        records = self.cursor.fetchall()

        print("Vulnerabilities found:")
        for record in records:
            print(", ".join(map(str, record)))

    def delete_vulnerabilities_by_id_and_type(self, event_id, vuln_type):
        """
        Deletes vulnerabilities from the table based on event_id and vulnerability type.

        Args:
            event_id (int): The event identifier.
            vuln_type (str): The type of vulnerability to delete.
        """
        try:
            self.cursor.execute("DELETE FROM vulnerabilities WHERE event_id = %s AND type = %s", (event_id, vuln_type))
            self.conn.commit()
            print(f"Deleted vulnerabilities with Event ID: {event_id} and Type: {vuln_type}")
        except Exception as e:
            print(f"Error deleting vulnerabilities: {e}")
            self.conn.rollback()



if __name__ == "__main__":
    url = os.getenv('MISP_URL')
    key = os.getenv('ADMIN_KEY')
    db_host = os.getenv('DB_HOST')
    db_name = os.getenv('DB_NAME')
    db_user = os.getenv('DB_USER')
    db_pass = os.getenv('DB_PASS')

    time.sleep(480)
    connector = MispConnector(url, key, db_name, db_user, db_pass, db_host)
    connector.search_and_save_vulnerabilities(patterns)
    connector.display_vulnerabilities()
    connector.close()
